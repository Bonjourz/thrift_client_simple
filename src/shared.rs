// Autogenerated by Thrift Compiler (0.14.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity)]
#![cfg_attr(rustfmt, rustfmt_skip)]


use thrift::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

// For Rust Thrift Async

use async_trait::async_trait;

use futures::Future;
use futures::task::Poll;
use std::pin::Pin;
use std::task::Context;


// Definition for async trait



//
// SharedService service client
//

/// This Thrift file can be included by other Thrift files that want to share
/// these definitions.
// Magic number: 09011020 generate for client async trait
#[async_trait]
pub trait TSharedServiceSyncClient {
  async fn add(&mut self, arg1: i32, arg2: i32) -> thrift::Result<i32>;
}


pub struct MyClient<IP, OP> {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

pub trait TMyInputProtocol {
  fn test_future_i(&mut self) -> MyInputProtocolFuture;
}

pub trait TMyOutputProtocol {
  fn test_future_o(&mut self) -> MyOutputProtocolFuture;
}

pub struct MyInputProtocolFuture {
  num : i32,
  max : i32,
}


impl Future for MyInputProtocolFuture {
  type Output = ();
  fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {
    println!("[gbd] MyInputProtocolFuture {}", self.num);
    Poll::Ready(())
  }
}

pub struct MyOutputProtocolFuture {
  num : i32,
  max : i32,
}

impl Future for MyOutputProtocolFuture {
  type Output = ();
  fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {
    if self.num < self.max {
      self.num = self.num + 1;
      println!("[gbd] poll here: {}", self.num);
      _cx.waker().wake_by_ref();
      Poll::Pending
    } else {
      println!("[gbd] OutputFuture return here: {}", self.num);
      Poll::Ready(())
    }
  }
}


pub struct MyInputProtocol {
}

impl TMyInputProtocol for MyInputProtocol {
  fn test_future_i(&mut self) -> MyInputProtocolFuture {
    MyInputProtocolFuture {
      num : 0,
      max : 5

    }
  }
}

pub struct MyOutputProtocol {
}

impl TMyOutputProtocol for MyOutputProtocol {
  fn test_future_o(&mut self) -> MyOutputProtocolFuture {
    MyOutputProtocolFuture {
      num: 1,
      max : 8
    }
  }
}

impl MyInputProtocol {
  pub fn new() -> Self {
    MyInputProtocol {

    }
  }
}

impl MyOutputProtocol {
  pub fn new() -> Self {
    MyOutputProtocol {
      
    }
  }

  pub async fn test_future_o() {
    
  }
}


// impl TMyInputProtocol

impl<IP, OP> MyClient<IP, OP> where IP: TMyInputProtocol, OP: TMyOutputProtocol {
  pub fn i_prot_mut(&mut self) -> &mut dyn TMyInputProtocol { &mut self._i_prot }
  
  pub fn o_prot_mut(&mut self) -> &mut dyn TMyOutputProtocol { &mut self._o_prot }
  
  fn sequence_number(&self) -> i32 { self._sequence_number }
  
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
  
  pub fn new_client(_i_prot: IP, _o_prot: OP) -> Self {
    MyClient {
      _i_prot: _i_prot,
      _o_prot: _o_prot,
      _sequence_number: 0,
    }
  }
}

#[async_trait]
pub trait TMyClient {
  async fn add(&mut self, _arg1: i32, _arg2: i32) -> thrift::Result<i32>;
}

// Magic number:09011023 generate for client_process impl
#[async_trait]
impl<IP, OP> TMyClient for MyClient<IP, OP>
  where IP: TMyInputProtocol + Send,
        OP: TMyOutputProtocol + Send  {
  async fn add(&mut self, _arg1: i32, _arg2: i32) -> thrift::Result<i32> {
    self._i_prot.test_future_i().await;
    self._o_prot.test_future_o().await;
    Ok(1)
    //let call_args = SharedServiceAddArgs { arg1: arg1, arg2: arg2 };
    //call_args.write_to_out_protocol(self.o_prot_mut()).await?;
  }
}